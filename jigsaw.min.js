"use strict";

function isMiniature() {
    return location.pathname.includes("/fullcpgrid/")
}

function alea(e, t) {
    return void 0 === t ? e * mrandom() : e + (t - e) * mrandom()
}

function intAlea(e, t) {
    return void 0 === t && (t = e, e = 0), mfloor(e + (t - e) * mrandom())
}

function arrayShuffle(e) {
    let t, s;
    for (let i = e.length - 1; i >= 1; --i) t = intAlea(0, i + 1), s = e[i], e[i] = e[t], e[t] = s;
    return e
}

function twist0(e, t, s) {
    function i(e, t) {
        return new Point(n.p1.x + e * a + t * r, n.p1.y + e * h + t * d)
    }
    const n = new Segment(e.points[0], e.points[1]),
        a = n.dx(),
        h = n.dy(),
        l = new Segment(t, s),
        o = n.pointOnRelative(.5),
        c = l.pointOnRelative(.5),
        p = new Segment(o, c),
        r = p.dx(),
        d = p.dy(),
        u = alea(.8, 1),
        m = alea(.9, 1),
        y = alea(.45, .55),
        x = i(y - 1 / 12 * u, 1 / 12 * m),
        z = i(y - 2 / 12 * u, .25 * m),
        g = i(y, 4 / 12 * m),
        f = i(y + 2 / 12 * u, .25 * m),
        v = i(y + 1 / 12 * u, 1 / 12 * m);
    e.points = [n.p1, new Point(n.p1.x + 5 / 12 * a * .52, n.p1.y + 5 / 12 * h * .52), new Point(x.x - 1 / 12 * r * .72, x.y - 1 / 12 * d * .72), x, new Point(x.x + 1 / 12 * r * .72, x.y + 1 / 12 * d * .72), new Point(z.x - 1 / 12 * r * .92, z.y - 1 / 12 * d * .92), z, new Point(z.x + 1 / 12 * r * .52, z.y + 1 / 12 * d * .52), new Point(g.x - 2 / 12 * a * .4, g.y - 2 / 12 * h * .4), g, new Point(g.x + 2 / 12 * a * .4, g.y + 2 / 12 * h * .4), new Point(f.x + 1 / 12 * r * .52, f.y + 1 / 12 * d * .52), f, new Point(f.x - 1 / 12 * r * .92, f.y - 1 / 12 * d * .92), new Point(v.x + 1 / 12 * r * .72, v.y + 1 / 12 * d * .72), v, new Point(v.x - 1 / 12 * r * .72, v.y - 1 / 12 * d * .72), new Point(n.p2.x - 5 / 12 * a * .52, n.p2.y - 5 / 12 * h * .52), n.p2], e.type = "z"
}

function twist1(e, t, s) {
    function i(e, t) {
        return new Point(n.p1.x + e * a + t * r, n.p1.y + e * h + t * d)
    }
    const n = new Segment(e.points[0], e.points[1]),
        a = n.dx(),
        h = n.dy(),
        l = new Segment(t, s),
        o = n.pointOnRelative(.5),
        c = l.pointOnRelative(.5),
        p = new Segment(o, c),
        r = p.dx(),
        d = p.dy(),
        u = i(alea(.3, .35), alea(-.05, .05)),
        m = i(alea(.45, .55), alea(.2, .3)),
        y = i(alea(.65, .78), alea(-.05, .05));
    e.points = [n.p1, n.p1, u, u, u, m, m, m, y, y, y, n.p2, n.p2], e.type = "z"
}

function twist2(e, t, s) {
    function i(e, t) {
        return new Point(n.p1.x + e * a + t * r, n.p1.y + e * h + t * d)
    }
    const n = new Segment(e.points[0], e.points[1]),
        a = n.dx(),
        h = n.dy(),
        l = new Segment(t, s),
        o = n.pointOnRelative(.5),
        c = l.pointOnRelative(.5),
        p = new Segment(o, c),
        r = p.dx(),
        d = p.dy(),
        u = alea(.45, .55),
        m = alea(.4, .5),
        y = i(u, m);
    let x = new Segment(n.p1, y);
    const z = x.pointOnRelative(2 / 3);
    x = new Segment(n.p2, y);
    const g = x.pointOnRelative(2 / 3);
    e.points = [n.p1, z, g, n.p2], e.type = "z"
}

function twist3(e, t, s) {
    e.points = [e.points[0], e.points[1]]
}

function loadInitialFile() {
    puzzle.srcImage.src = imgSrc
}

function imageLoaded(e) {
    events.push({
        event: "srcImageLoaded"
    }), e.imageLoaded = !0
}

function fitImage(e, t, s) {
    let i = e.naturalWidth,
        n = e.naturalHeight,
        a = t,
        h = a * n / i;
    h > s && (h = s, a = h * i / n), e.style.position = "absolute", e.style.width = a + "px", e.style.height = h + "px", e.style.top = "50%", e.style.left = "50%", e.style.transform = "translate(-50%,-50%)"
}
let puzzle, autoStart;
const mhypot = Math.hypot,
    mrandom = Math.random,
    mmax = Math.max,
    mmin = Math.min,
    mround = Math.round,
    mfloor = Math.floor,
    msqrt = Math.sqrt,
    mabs = Math.abs;
class Point {
    constructor(e, t) {
        this.x = Number(e), this.y = Number(t)
    }
    copy() {
        return new Point(this.x, this.y)
    }
    distance(e) {
        return mhypot(this.x - e.x, this.y - e.y)
    }
}
class Segment {
    constructor(e, t) {
        this.p1 = new Point(e.x, e.y), this.p2 = new Point(t.x, t.y)
    }
    dx() {
        return this.p2.x - this.p1.x
    }
    dy() {
        return this.p2.y - this.p1.y
    }
    length() {
        return mhypot(this.dx(), this.dy())
    }
    pointOnRelative(e) {
        let t = this.dx(),
            s = this.dy();
        return new Point(this.p1.x + e * t, this.p1.y + e * s)
    }
}
class Side {
    constructor() {
        this.type = "", this.points = []
    }
    reversed() {
        const e = new Side;
        return e.type = this.type, e.points = this.points.slice().reverse(), e
    }
    scale(e) {
        const t = e.scalex,
            s = e.scaley;
        this.scaledPoints = this.points.map(e => new Point(e.x * t, e.y * s))
    }
    drawPath(e, t, s, i) {
        if (i || e.moveTo(this.scaledPoints[0].x + t, this.scaledPoints[0].y + s), "d" == this.type) e.lineTo(this.scaledPoints[1].x + t, this.scaledPoints[1].y + s);
        else
            for (let i = 1; i < this.scaledPoints.length - 1; i += 3) e.bezierCurveTo(this.scaledPoints[i].x + t, this.scaledPoints[i].y + s, this.scaledPoints[i + 1].x + t, this.scaledPoints[i + 1].y + s, this.scaledPoints[i + 2].x + t, this.scaledPoints[i + 2].y + s)
    }
}
class Piece {
    constructor(e, t) {
        this.ts = new Side, this.rs = new Side, this.bs = new Side, this.ls = new Side, this.kx = e, this.ky = t
    }
    scale(e) {
        this.ts.scale(e), this.rs.scale(e), this.bs.scale(e), this.ls.scale(e)
    }
}
class PolyPiece {
    constructor(e, t) {
        this.pckxmin = e.kx, this.pckxmax = e.kx + 1, this.pckymin = e.ky, this.pckymax = e.ky + 1, this.pieces = [e], this.puzzle = t, this.listLoops(), this.canvas = document.createElement("CANVAS"), t.container.appendChild(this.canvas), this.canvas.classList.add("polypiece"), this.ctx = this.canvas.getContext("2d")
    }
    merge(e) {
        const t = this.pckxmin,
            s = this.pckymin,
            i = this.puzzle.polyPieces.indexOf(e);
        this.puzzle.polyPieces.splice(i, 1), this.puzzle.container.removeChild(e.canvas);
        for (let t = 0; t < e.pieces.length; ++t) this.pieces.push(e.pieces[t]), e.pieces[t].kx < this.pckxmin && (this.pckxmin = e.pieces[t].kx), e.pieces[t].kx + 1 > this.pckxmax && (this.pckxmax = e.pieces[t].kx + 1), e.pieces[t].ky < this.pckymin && (this.pckymin = e.pieces[t].ky), e.pieces[t].ky + 1 > this.pckymax && (this.pckymax = e.pieces[t].ky + 1);
        this.pieces.sort(function(e, t) {
            return e.ky < t.ky ? -1 : e.ky > t.ky ? 1 : e.kx < t.kx ? -1 : e.kx > t.kx ? 1 : 0
        }), this.listLoops(), this.drawImage(), this.moveTo(this.x + this.puzzle.scalex * (this.pckxmin - t), this.y + this.puzzle.scaley * (this.pckymin - s)), this.puzzle.evaluateZIndex()
    }
    ifNear(e) {
        let t, s, i = this.puzzle,
            n = this.x - i.scalex * this.pckxmin,
            a = this.y - i.scaley * this.pckymin,
            h = e.x - i.scalex * e.pckxmin,
            l = e.y - i.scaley * e.pckymin;
        if (mhypot(n - h, a - l) >= i.dConnect) return !1;
        for (let i = this.pieces.length - 1; i >= 0; --i) {
            t = this.pieces[i];
            for (let i = e.pieces.length - 1; i >= 0; --i) {
                if (s = e.pieces[i], t.kx == s.kx && 1 == mabs(t.ky - s.ky)) return !0;
                if (t.ky == s.ky && 1 == mabs(t.kx - s.kx)) return !0
            }
        }
        return !1
    }
    listLoops() {
        function e(e, t, i) {
            let n;
            switch (i) {
                case 0:
                    t--;
                    break;
                case 1:
                    e++;
                    break;
                case 2:
                    t++;
                    break;
                case 3:
                    e--
            }
            for (n = 0; n < s.pieces.length; n++)
                if (e == s.pieces[n].kx && t == s.pieces[n].ky) return !0;
            return !1
        }

        function t(e, t, s) {
            let i;
            for (i = 0; i < r.length; i++)
                if (e == r[i].kx && t == r[i].ky && s == r[i].edge) return i;
            return !1
        }
        const s = this;
        let i, n, a, h, l, o, c, p = [],
            r = [],
            d = [
                [{
                    dkx: 0,
                    dky: 0,
                    edge: 1
                }, {
                    dkx: 1,
                    dky: 0,
                    edge: 0
                }, {
                    dkx: 1,
                    dky: -1,
                    edge: 3
                }],
                [{
                    dkx: 0,
                    dky: 0,
                    edge: 2
                }, {
                    dkx: 0,
                    dky: 1,
                    edge: 1
                }, {
                    dkx: 1,
                    dky: 1,
                    edge: 0
                }],
                [{
                    dkx: 0,
                    dky: 0,
                    edge: 3
                }, {
                    dkx: -1,
                    dky: 0,
                    edge: 2
                }, {
                    dkx: -1,
                    dky: 1,
                    edge: 1
                }],
                [{
                    dkx: 0,
                    dky: 0,
                    edge: 0
                }, {
                    dkx: 0,
                    dky: -1,
                    edge: 3
                }, {
                    dkx: -1,
                    dky: -1,
                    edge: 2
                }]
            ];
        for (i = 0; i < this.pieces.length; i++)
            for (n = 0; n < 4; n++) e(this.pieces[i].kx, this.pieces[i].ky, n) || r.push({
                kx: this.pieces[i].kx,
                ky: this.pieces[i].ky,
                edge: n,
                kp: i
            });
        for (; r.length > 0;) {
            for (a = [], h = r[0], a.push(h), r.splice(0, 1);;) {
                for (l = 0; l < 3; l++)
                    if (c = d[h.edge][l], o = t(h.kx + c.dkx, h.ky + c.dky, c.edge), !1 !== o) {
                        h = r[o], a.push(h), r.splice(o, 1);
                        break
                    } if (!1 === o) break
            }
            p.push(a)
        }
        this.tbLoops = p.map(e => e.map(e => {
            let t = this.pieces[e.kp];
            return 0 == e.edge ? t.ts : 1 == e.edge ? t.rs : 2 == e.edge ? t.bs : t.ls
        }))
    }
    drawPath(e, t, s) {
        this.tbLoops.forEach(i => {
            let n = !1;
            i.forEach(i => {
                i.drawPath(e, t, s, n), n = !0
            }), e.closePath()
        })
    }
    drawImage() {
        puzzle = this.puzzle, this.nx = this.pckxmax - this.pckxmin + 1, this.ny = this.pckymax - this.pckymin + 1, this.canvas.width = this.nx * puzzle.scalex, this.canvas.height = this.ny * puzzle.scaley, this.offsx = (this.pckxmin - .5) * puzzle.scalex, this.offsy = (this.pckymin - .5) * puzzle.scaley, this.path = new Path2D, this.drawPath(this.path, -this.offsx, -this.offsy), this.ctx.fillStyle = "none", this.ctx.shadowColor = "rgba(0, 0, 0, 0.5)", this.ctx.shadowBlur = 4, this.ctx.shadowOffsetX = 4, this.ctx.shadowOffsetY = 4, this.ctx.fill(this.path), this.ctx.shadowColor = "rgba(0, 0, 0, 0)", this.pieces.forEach((e, t) => {
            this.ctx.save();
            const s = new Path2D,
                i = -this.offsx,
                n = -this.offsy;
            e.ts.drawPath(s, i, n, !1), e.rs.drawPath(s, i, n, !0), e.bs.drawPath(s, i, n, !0), e.ls.drawPath(s, i, n, !0), s.closePath(), this.ctx.clip(s);
            const a = e.kx ? (e.kx - .5) * puzzle.scalex : 0,
                h = e.ky ? (e.ky - .5) * puzzle.scaley : 0,
                l = (e.kx ? 0 : puzzle.scalex / 2) + (e.kx - this.pckxmin) * puzzle.scalex,
                o = (e.ky ? 0 : puzzle.scaley / 2) + (e.ky - this.pckymin) * puzzle.scaley;
            let c = 2 * puzzle.scalex,
                p = 2 * puzzle.scaley;
            a + c > puzzle.gameCanvas.width && (c = puzzle.gameCanvas.width - a), h + p > puzzle.gameCanvas.height && (p = puzzle.gameCanvas.height - h), this.ctx.drawImage(puzzle.gameCanvas, a, h, c, p, l, o, c, p), this.ctx.translate(puzzle.embossThickness / 2, -puzzle.embossThickness / 2), this.ctx.lineWidth = puzzle.embossThickness, this.ctx.strokeStyle = "rgba(0, 0, 0, 0.35)", this.ctx.stroke(s), this.ctx.translate(-puzzle.embossThickness, puzzle.embossThickness), this.ctx.strokeStyle = "rgba(255, 255, 255, 0.35)", this.ctx.stroke(s), this.ctx.restore()
        })
    }
    moveTo(e, t) {
        this.x = e, this.y = t, this.canvas.style.left = e + "px", this.canvas.style.top = t + "px"
    }
    moveToInitialPlace() {
        const e = this.puzzle;
        this.moveTo(e.offsx + (this.pckxmin - .5) * e.scalex, e.offsy + (this.pckymin - .5) * e.scaley)
    }
}
class Puzzle {
    constructor(e) {
        function t() {
            events.push({
                event: "leave"
            })
        }
        this.autoStart = !1, this.container = "string" == typeof e.container ? document.getElementById(e.container) : e.container, this.container.addEventListener("mousedown", e => {
            e.preventDefault(), events.push({
                event: "touch",
                position: this.relativeMouseCoordinates(e)
            })
        }), this.container.addEventListener("touchstart", e => {
            if (e.preventDefault(), 1 != e.touches.length) return;
            let t = e.touches[0];
            events.push({
                event: "touch",
                position: this.relativeMouseCoordinates(t)
            })
        }, {
            passive: !1
        }), this.container.addEventListener("mouseup", e => {
            e.preventDefault(), t()
        }), this.container.addEventListener("touchend", t), this.container.addEventListener("touchleave", t), this.container.addEventListener("touchcancel", t), this.container.addEventListener("mousemove", e => {
            e.preventDefault(), events.length && "move" == events[events.length - 1].event && events.pop(), events.push({
                event: "move",
                position: this.relativeMouseCoordinates(e)
            })
        }), this.container.addEventListener("touchmove", e => {
            if (e.preventDefault(), 1 != e.touches.length) return;
            let t = e.touches[0];
            events.length && "move" == events[events.length - 1].event && events.pop(), events.push({
                event: "move",
                position: this.relativeMouseCoordinates(t)
            })
        }, {
            passive: !1
        }), this.gameCanvas = document.createElement("CANVAS"), this.container.appendChild(this.gameCanvas), this.srcImage = new Image, this.imageLoaded = !1, this.srcImage.addEventListener("load", () => imageLoaded(this))
    }
    getContainerSize() {
        let e = window.getComputedStyle(this.container);
        this.contWidth = parseFloat(e.width), this.contHeight = parseFloat(e.height)
    }
    create() {
        this.container.innerHTML = "", this.getContainerSize(), this.computenxAndny(), this.relativeHeight = this.srcImage.naturalHeight / this.ny / (this.srcImage.naturalWidth / this.nx), this.defineShapes({
            coeffDecentr: .12,
            twistf: [twist0, twist1, twist2, twist3][document.getElementById("shape").value - 1]
        }), this.polyPieces = [], this.pieces.forEach(e => e.forEach(e => {
            this.polyPieces.push(new PolyPiece(e, this))
        })), arrayShuffle(this.polyPieces), this.evaluateZIndex()
    }
    computenxAndny() {
        let e, t, s, i, n, a = this.srcImage.naturalWidth,
            h = this.srcImage.naturalHeight,
            l = this.nbPieces,
            o = 1e9,
            c = mround(msqrt(l * a / h)),
            p = mround(l / c);
        for (t = 0; t < 5; t++)
            for (i = p + t - 2, e = 0; e < 5; e++) n = c + e - 2, s = n * h / i / a, s = s + 1 / s - 2, s += mabs(1 - n * i / l), s < o && (o = s, this.nx = n, this.ny = i)
    }
    defineShapes(e) {
        let {
            coeffDecentr: t,
            twistf: s
        } = e;
        const i = [],
            n = this.nx,
            a = this.ny;
        let h;
        for (let e = 0; e <= a; ++e) {
            i[e] = [];
            for (let s = 0; s <= n; ++s) i[e][s] = new Point(s + alea(-t, t), e + alea(-t, t)), 0 == s && (i[e][s].x = 0), s == n && (i[e][s].x = n), 0 == e && (i[e][s].y = 0), e == a && (i[e][s].y = a)
        }
        this.pieces = [];
        for (let e = 0; e < a; ++e) {
            this.pieces[e] = [];
            for (let t = 0; t < n; ++t) this.pieces[e][t] = h = new Piece(t, e), 0 == e ? (h.ts.points = [i[e][t], i[e][t + 1]], h.ts.type = "d") : h.ts = this.pieces[e - 1][t].bs.reversed(), h.rs.points = [i[e][t + 1], i[e + 1][t + 1]], h.rs.type = "d", t < n - 1 && (intAlea(2) ? s(h.rs, i[e][t], i[e + 1][t]) : s(h.rs, i[e][t + 2], i[e + 1][t + 2])), 0 == t ? (h.ls.points = [i[e + 1][t], i[e][t]], h.ls.type = "d") : h.ls = this.pieces[e][t - 1].rs.reversed(), h.bs.points = [i[e + 1][t + 1], i[e + 1][t]], h.bs.type = "d", e < a - 1 && (intAlea(2) ? s(h.bs, i[e][t + 1], i[e][t]) : s(h.bs, i[e + 2][t + 1], i[e + 2][t]))
        }
    }
    scale() {
        const e = .95 * this.contWidth,
            t = .95 * this.contHeight;
        this.gameHeight = t, this.gameWidth = this.gameHeight * this.srcImage.naturalWidth / this.srcImage.naturalHeight, this.gameWidth > e && (this.gameWidth = e, this.gameHeight = this.gameWidth * this.srcImage.naturalHeight / this.srcImage.naturalWidth), this.gameCanvas.width = this.gameWidth, this.gameCanvas.height = this.gameHeight, this.gameCtx = this.gameCanvas.getContext("2d"), this.gameCtx.drawImage(this.srcImage, 0, 0, this.gameWidth, this.gameHeight), this.gameCanvas.classList.add("gameCanvas"), this.gameCanvas.style.zIndex = 500, this.scalex = this.gameWidth / this.nx, this.scaley = this.gameHeight / this.ny, this.pieces.forEach(e => {
            e.forEach(e => e.scale(this))
        }), this.offsx = (this.contWidth - this.gameWidth) / 2, this.offsy = (this.contHeight - this.gameHeight) / 2, this.dConnect = mmax(10, mmin(this.scalex, this.scaley) / 10), this.embossThickness = mmin(2 + this.scalex / 200 * 3, 5)
    }
    relativeMouseCoordinates(e) {
        const t = this.container.getBoundingClientRect();
        return {
            x: e.clientX - t.x,
            y: e.clientY - t.y
        }
    }
    limitRectangle(e) {
        e.x0 = mmin(mmax(e.x0, -this.scalex / 2), this.contWidth - 1.5 * this.scalex), e.x1 = mmin(mmax(e.x1, -this.scalex / 2), this.contWidth - 1.5 * this.scalex), e.y0 = mmin(mmax(e.y0, -this.scaley / 2), this.contHeight - 1.5 * this.scaley), e.y1 = mmin(mmax(e.y1, -this.scaley / 2), this.contHeight - 1.5 * this.scaley)
    }
    spreadInRectangle(e) {
        this.limitRectangle(e), this.polyPieces.forEach(t => t.moveTo(alea(e.x0, e.x1), alea(e.y0, e.y1)))
    }
    spreadSetInRectangle(e, t) {
        this.limitRectangle(t), e.forEach(e => e.moveTo(alea(t.x0, t.x1), alea(t.y0, t.y1)))
    }
    optimInitial() {
        const e = -this.scalex / 2,
            t = -this.scaley / 2,
            s = this.contWidth - 1.5 * this.scalex,
            i = this.contHeight - 1.5 * this.scaley;
        let n = this.contWidth - this.gameWidth,
            a = this.contHeight - this.gameHeight,
            h = [0, 0, 0, 0],
            l = [];
        if (n > 1.5 * this.scalex && (h[1] = 1, l[1] = {
                x0: this.gameWidth - .5 * this.scalex,
                x1: s,
                y0: t,
                y1: i
            }), n > 3 * this.scalex && (h[3] = 1, l[3] = {
                x0: e,
                x1: n / 2 - 1.5 * this.scalex,
                y0: t,
                y1: i
            }, l[1].x0 = this.contWidth - n / 2 - .5 * this.scalex), a > 1.5 * this.scaley && (h[2] = 1, l[2] = {
                x0: e,
                x1: s,
                y0: this.gameHeight - .5 * this.scaley,
                y1: this.contHeight - 1.5 * this.scaley
            }), a > 3 * this.scaley && (h[0] = 1, l[0] = {
                x0: e,
                x1: s,
                y0: t,
                y1: a / 2 - 1.5 * this.scaley
            }, l[2].y0 = this.contHeight - a / 2 - .5 * this.scaley), h.reduce((e, t) => e + t) < 2) return void(n - a > .2 * this.scalex || h[1] ? this.spreadInRectangle({
            x0: this.gameWidth - this.scalex / 2,
            x1: s,
            y0: t,
            y1: i
        }) : a - n > .2 * this.scalex || h[2] ? this.spreadInRectangle({
            x0: e,
            x1: s,
            y0: this.gameHeight - this.scaley / 2,
            y1: i
        }) : this.gameWidth > this.gameHeight ? this.spreadInRectangle({
            x0: e,
            x1: s,
            y0: this.gameHeight - this.scaley / 2,
            y1: i
        }) : this.spreadInRectangle({
            x0: this.gameWidth - this.scalex / 2,
            x1: s,
            y0: t,
            y1: i
        }));
        let o = [];
        l.forEach(e => {
            o.push(e)
        });
        let c = 0;
        const p = this.nx * this.ny;
        for (let e = 0; e < o.length; ++e) {
            let t = mround((e + 1) / o.length * p);
            this.spreadSetInRectangle(this.polyPieces.slice(c, t), o[e]), c = t
        }
        arrayShuffle(this.polyPieces), this.evaluateZIndex()
    }
    evaluateZIndex() {
        for (let e = this.polyPieces.length - 1; e > 0; --e) this.polyPieces[e].pieces.length > this.polyPieces[e - 1].pieces.length && ([this.polyPieces[e], this.polyPieces[e - 1]] = [this.polyPieces[e - 1], this.polyPieces[e]]);
        this.polyPieces.forEach((e, t) => {
            e.canvas.style.zIndex = t + 10
        }), this.zIndexSup = this.polyPieces.length + 10
    }
}
let loadFile, animate;
{
    let e = document.createElement("input");

    function getFile() {
        if (0 == this.files.length) return;
        this.files[0];
        let e = new FileReader;
        e.addEventListener("load", () => {
            puzzle.srcImage.src = e.result
        }), e.readAsDataURL(this.files[0])
    }
    e.setAttribute("type", "file"), e.style.display = "none", e.addEventListener("change", getFile), loadFile = function(t) {
        e.setAttribute("accept", "image/*"), e.value = null, e.click()
    }
}
let events = [];
{
    let e, t, s = 0;
    animate = function() {
        let i;
        if (requestAnimationFrame(animate), events.length && (i = events.shift()), i && "reset" == i.event && (s = 0), i && "srcImageLoaded" == i.event && (s = 0), i && "resize" == i.event) {
            if (puzzle.prevWidth = puzzle.contWidth, puzzle.prevHeight = puzzle.contHeight, puzzle.getContainerSize(), 15 == s || s > 60) puzzle.getContainerSize(), fitImage(t, .95 * puzzle.contWidth, .95 * puzzle.contHeight);
            else if (s >= 25) {
                puzzle.prevGameWidth = puzzle.gameWidth, puzzle.prevGameHeight = puzzle.gameHeight, puzzle.scale();
                let e = puzzle.contWidth / puzzle.prevWidth;
                puzzle.polyPieces.forEach(t => {
                    let s = puzzle.contWidth / 2 - (puzzle.prevWidth / 2 - t.x) * e,
                        i = puzzle.contHeight / 2 - (puzzle.prevHeight / 2 - t.y) * e;
                    s = mmin(mmax(s, -puzzle.scalex / 2), puzzle.contWidth - 1.5 * puzzle.scalex), i = mmin(mmax(i, -puzzle.scaley / 2), puzzle.contHeight - 1.5 * puzzle.scaley), t.moveTo(s, i), t.drawImage()
                })
            }
        } else switch (s) {
            case 0:
                s = 10;
                break;
            case 10:
                if (!puzzle.imageLoaded) return;
                puzzle.container.innerHTML = "", t = document.createElement("img"), t.src = puzzle.srcImage.src, puzzle.getContainerSize(), fitImage(t, .95 * puzzle.contWidth, .95 * puzzle.contHeight), t.style.boxShadow = "4px 4px 4px rgba(0, 0, 0, 0.5)", puzzle.container.appendChild(t), s = 15;
                break;
            case 15:
                if (autoStart && (i = {
                        event: "nbpieces",
                        nbpieces: 12
                    }), autoStart = !1, !i) return;
                if ("nbpieces" != i.event) return "srcImageLoaded" == i.event ? void(s = 10) : void 0;
                puzzle.nbPieces = i.nbpieces, s = 20;
            case 20:
                menu.close(), puzzle.create(), puzzle.scale(), puzzle.polyPieces.forEach(e => {
                    e.drawImage(), e.moveToInitialPlace()
                }), puzzle.gameCanvas.style.top = puzzle.offsy + "px", puzzle.gameCanvas.style.left = puzzle.offsx + "px", puzzle.gameCanvas.style.display = "block", s = 25;
                break;
            case 25:
                puzzle.gameCanvas.style.display = "none", puzzle.polyPieces.forEach(e => {
                    e.canvas.classList.add("moving")
                }), s = 30;
                break;
            case 30:
                puzzle.optimInitial(), setTimeout(() => events.push({
                    event: "finished"
                }), 1200), s = 35;
                break;
            case 35:
                if (!i || "finished" != i.event) return;
                puzzle.polyPieces.forEach(e => {
                    e.canvas.classList.remove("moving")
                }), s = 50;
                break;
            case 50:
                if (!i) return;
                if ("nbpieces" == i.event) return puzzle.nbPieces = i.nbpieces, void(s = 20);
                if ("touch" != i.event) return;
                e = {
                    xMouseInit: i.position.x,
                    yMouseInit: i.position.y
                };
                for (let t = puzzle.polyPieces.length - 1; t >= 0; --t) {
                    let n = puzzle.polyPieces[t];
                    if (n.ctx.isPointInPath(n.path, i.position.x - n.x, i.position.y - n.y)) return e.pp = n, e.ppXInit = n.x, e.ppYInit = n.y, puzzle.polyPieces.splice(t, 1), puzzle.polyPieces.push(n), n.canvas.style.zIndex = puzzle.zIndexSup, void(s = 55)
                }
                break;
            case 55:
                if (!i) return;
                switch (i.event) {
                    case "move":
                        e.pp.moveTo(i.position.x - e.xMouseInit + e.ppXInit, i.position.y - e.yMouseInit + e.ppYInit);
                        break;
                    case "leave":
                        let t;
                        do {
                            t = !1;
                            for (let s = puzzle.polyPieces.length - 1; s >= 0; --s) {
                                let i = puzzle.polyPieces[s];
                                if (i != e.pp && e.pp.ifNear(i)) {
                                    i.pieces.length > e.pp.pieces.length ? (i.merge(e.pp), e.pp = i) : e.pp.merge(i), t = !0;
                                    break
                                }
                            }
                        } while (t);
                        return puzzle.evaluateZIndex(), s = 50, void(1 == puzzle.polyPieces.length && (s = 60))
                }
                break;
            case 60:
                puzzle.onComplete && "function" == typeof puzzle.onComplete && puzzle.onComplete(), puzzle.container.innerHTML = "", puzzle.getContainerSize(), fitImage(t, .95 * puzzle.contWidth, .95 * puzzle.contHeight), t.style.boxShadow = "4px 4px 4px rgba(0, 0, 0, 0.5)", t.style.left = (puzzle.polyPieces[0].x + puzzle.scalex / 2 + puzzle.gameWidth / 2) / puzzle.contWidth * 100 + "%", t.style.top = (puzzle.polyPieces[0].y + puzzle.scaley / 2 + puzzle.gameHeight / 2) / puzzle.contHeight * 100 + "%", t.classList.add("moving"), setTimeout(() => t.style.top = t.style.left = "50%", 0), puzzle.container.appendChild(t), s = 65, menu.open();
            case 65:
                if (i && "nbpieces" == i.event) return puzzle.nbPieces = i.nbpieces, void(s = 20);
                break;
            case 9999:
                break;
            default:
                let n = s;
                throw s = 9999, "oops, unknown state " + n
        }
    }
}
let menu = function() {
    let e = {
        items: []
    };
    document.querySelectorAll("#menu li").forEach(t => {
        let s = e.items.length,
            i = {
                element: t,
                kItem: s
            };
        e.items[s] = i
    }), e.open = function() {
        e.items.forEach(e => e.element.style.display = "block"), e.opened = !0
    }, e.close = function() {
        e.items.forEach((e, t) => {
            t > 0 && (e.element.style.display = "none")
        }), e.opened = !1
    }, e.items[0].element.addEventListener("click", () => {
        e.opened ? e.close() : e.open()
    }), e.items[1].element.addEventListener("click", loadInitialFile), e.items[2].element.addEventListener("click", loadFile), e.items[3].element.addEventListener("click", () => {});
    for (let t = 4; t < e.items.length; ++t) e.items[t].element.addEventListener("click", () => events.push({
        event: "nbpieces",
        nbpieces: [12, 25, 50, 100, 200][t - 4]
    }));
    return e
}();
menu.close(), window.addEventListener("resize", e => {
    events.length && "resize" == events[events.length - 1].event || events.push({
        event: "resize"
    })
}), puzzle = new Puzzle({
    container: "forPuzzle"
}), autoStart = isMiniature(), loadInitialFile(), requestAnimationFrame(animate);